<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.18"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Agora C++ API Reference for All Platforms: agora::media::IVideoFrameObserver Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Agora C++ API Reference for All Platforms
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.18 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceagora.html">agora</a></li><li class="navelem"><a class="el" href="namespaceagora_1_1media.html">media</a></li><li class="navelem"><a class="el" href="classagora_1_1media_1_1_i_video_frame_observer.html">IVideoFrameObserver</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classagora_1_1media_1_1_i_video_frame_observer-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">agora::media::IVideoFrameObserver Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p>Inherited by <a class="el" href="classagora_1_1media_1_1_i_video_frame_observer_ex.html">agora::media::IVideoFrameObserverEx</a>.</p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:aa0a690ef35d3813937a396d39ef74e65"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classagora_1_1media_1_1_i_video_frame_observer.html#aa0a690ef35d3813937a396d39ef74e65">VIDEO_FRAME_PROCESS_MODE</a> { <a class="el" href="classagora_1_1media_1_1_i_video_frame_observer.html#aa0a690ef35d3813937a396d39ef74e65ac0338fc908faa61cc99587c6381d5829">PROCESS_MODE_READ_ONLY</a>, 
<a class="el" href="classagora_1_1media_1_1_i_video_frame_observer.html#aa0a690ef35d3813937a396d39ef74e65ae90137a3e8b393f7f6b7ab8488d854a8">PROCESS_MODE_READ_WRITE</a>
 }</td></tr>
<tr class="separator:aa0a690ef35d3813937a396d39ef74e65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae60399181e83d7e93ad759b2ab549b97"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structagora_1_1media_1_1base_1_1_video_frame.html">media::base::VideoFrame</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classagora_1_1media_1_1_i_video_frame_observer.html#ae60399181e83d7e93ad759b2ab549b97">VideoFrame</a></td></tr>
<tr class="separator:ae60399181e83d7e93ad759b2ab549b97"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aa2cb7c83f1fe21095576dfc14fcdc12e"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classagora_1_1media_1_1_i_video_frame_observer.html#aa2cb7c83f1fe21095576dfc14fcdc12e">~IVideoFrameObserver</a> ()</td></tr>
<tr class="separator:aa2cb7c83f1fe21095576dfc14fcdc12e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace896f8111e36f690d0132a7a5c2c603"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classagora_1_1media_1_1_i_video_frame_observer.html#ace896f8111e36f690d0132a7a5c2c603">onCaptureVideoFrame</a> (<a class="el" href="namespaceagora_1_1rtc.html#ac6699b3c40e047af097d877115dde751">agora::rtc::VIDEO_SOURCE_TYPE</a> sourceType, <a class="el" href="classagora_1_1media_1_1_i_video_frame_observer.html#ae60399181e83d7e93ad759b2ab549b97">VideoFrame</a> &amp;videoFrame)=0</td></tr>
<tr class="separator:ace896f8111e36f690d0132a7a5c2c603"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabbf70d93e52f748b9c03d90a73fe65e"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classagora_1_1media_1_1_i_video_frame_observer.html#aabbf70d93e52f748b9c03d90a73fe65e">onPreEncodeVideoFrame</a> (<a class="el" href="namespaceagora_1_1rtc.html#ac6699b3c40e047af097d877115dde751">agora::rtc::VIDEO_SOURCE_TYPE</a> sourceType, <a class="el" href="classagora_1_1media_1_1_i_video_frame_observer.html#ae60399181e83d7e93ad759b2ab549b97">VideoFrame</a> &amp;videoFrame)=0</td></tr>
<tr class="separator:aabbf70d93e52f748b9c03d90a73fe65e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b207e2905a273073f5b4592fa579136"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classagora_1_1media_1_1_i_video_frame_observer.html#a0b207e2905a273073f5b4592fa579136">onMediaPlayerVideoFrame</a> (<a class="el" href="classagora_1_1media_1_1_i_video_frame_observer.html#ae60399181e83d7e93ad759b2ab549b97">VideoFrame</a> &amp;videoFrame, int mediaPlayerId)=0</td></tr>
<tr class="separator:a0b207e2905a273073f5b4592fa579136"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55a50434efe819a3dcb74ffd0799b847"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classagora_1_1media_1_1_i_video_frame_observer.html#a55a50434efe819a3dcb74ffd0799b847">onRenderVideoFrame</a> (const char *channelId, <a class="el" href="namespaceagora_1_1rtc.html#ab650539cb2bdcf8382d0aa32c6d70aa7">rtc::uid_t</a> remoteUid, <a class="el" href="classagora_1_1media_1_1_i_video_frame_observer.html#ae60399181e83d7e93ad759b2ab549b97">VideoFrame</a> &amp;videoFrame)=0</td></tr>
<tr class="separator:a55a50434efe819a3dcb74ffd0799b847"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4c50b6e2052a1b656fdca43439c55cd"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classagora_1_1media_1_1_i_video_frame_observer.html#ad4c50b6e2052a1b656fdca43439c55cd">onTranscodedVideoFrame</a> (<a class="el" href="classagora_1_1media_1_1_i_video_frame_observer.html#ae60399181e83d7e93ad759b2ab549b97">VideoFrame</a> &amp;videoFrame)=0</td></tr>
<tr class="separator:ad4c50b6e2052a1b656fdca43439c55cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af147400f7477416724546852894bb7da"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classagora_1_1media_1_1_i_video_frame_observer.html#aa0a690ef35d3813937a396d39ef74e65">VIDEO_FRAME_PROCESS_MODE</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classagora_1_1media_1_1_i_video_frame_observer.html#af147400f7477416724546852894bb7da">getVideoFrameProcessMode</a> ()</td></tr>
<tr class="separator:af147400f7477416724546852894bb7da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abce7f145af45f90bfd8c9b0211c875db"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceagora_1_1media_1_1base.html#ab530007c5b083146b9cebefb46f931e2">base::VIDEO_PIXEL_FORMAT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classagora_1_1media_1_1_i_video_frame_observer.html#abce7f145af45f90bfd8c9b0211c875db">getVideoFormatPreference</a> ()</td></tr>
<tr class="separator:abce7f145af45f90bfd8c9b0211c875db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd5bb439a9951a83f08d8c0a81468dcb"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classagora_1_1media_1_1_i_video_frame_observer.html#afd5bb439a9951a83f08d8c0a81468dcb">getRotationApplied</a> ()</td></tr>
<tr class="separator:afd5bb439a9951a83f08d8c0a81468dcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc5cce81bf1c008e9335a0423ca45991"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classagora_1_1media_1_1_i_video_frame_observer.html#afc5cce81bf1c008e9335a0423ca45991">getMirrorApplied</a> ()</td></tr>
<tr class="separator:afc5cce81bf1c008e9335a0423ca45991"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4c174389264630ffb1b2d24c6030013"><td class="memItemLeft" align="right" valign="top">virtual uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classagora_1_1media_1_1_i_video_frame_observer.html#ad4c174389264630ffb1b2d24c6030013">getObservedFramePosition</a> ()</td></tr>
<tr class="separator:ad4c174389264630ffb1b2d24c6030013"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d6db5dbead74855002812bac087c9e2"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classagora_1_1media_1_1_i_video_frame_observer.html#a2d6db5dbead74855002812bac087c9e2">isExternal</a> ()</td></tr>
<tr class="separator:a2d6db5dbead74855002812bac087c9e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The <a class="el" href="classagora_1_1media_1_1_i_video_frame_observer.html">IVideoFrameObserver</a> class. </p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="ae60399181e83d7e93ad759b2ab549b97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae60399181e83d7e93ad759b2ab549b97">&#9670;&nbsp;</a></span>VideoFrame</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structagora_1_1media_1_1base_1_1_video_frame.html">media::base::VideoFrame</a> <a class="el" href="classagora_1_1media_1_1_i_video_frame_observer.html#ae60399181e83d7e93ad759b2ab549b97">agora::media::IVideoFrameObserver::VideoFrame</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="aa0a690ef35d3813937a396d39ef74e65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0a690ef35d3813937a396d39ef74e65">&#9670;&nbsp;</a></span>VIDEO_FRAME_PROCESS_MODE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classagora_1_1media_1_1_i_video_frame_observer.html#aa0a690ef35d3813937a396d39ef74e65">agora::media::IVideoFrameObserver::VIDEO_FRAME_PROCESS_MODE</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The process mode of the video frame: </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="aa0a690ef35d3813937a396d39ef74e65ac0338fc908faa61cc99587c6381d5829"></a>PROCESS_MODE_READ_ONLY&#160;</td><td class="fielddoc"><p>Read-only mode.</p>
<p>In this mode, you do not modify the video frame. The video frame observer is a renderer. </p>
</td></tr>
<tr><td class="fieldname"><a id="aa0a690ef35d3813937a396d39ef74e65ae90137a3e8b393f7f6b7ab8488d854a8"></a>PROCESS_MODE_READ_WRITE&#160;</td><td class="fielddoc"><p>Read and write mode.</p>
<p>In this mode, you modify the video frame. The video frame observer is a video filter. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="aa2cb7c83f1fe21095576dfc14fcdc12e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2cb7c83f1fe21095576dfc14fcdc12e">&#9670;&nbsp;</a></span>~IVideoFrameObserver()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual agora::media::IVideoFrameObserver::~IVideoFrameObserver </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ace896f8111e36f690d0132a7a5c2c603"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace896f8111e36f690d0132a7a5c2c603">&#9670;&nbsp;</a></span>onCaptureVideoFrame()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool agora::media::IVideoFrameObserver::onCaptureVideoFrame </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceagora_1_1rtc.html#ac6699b3c40e047af097d877115dde751">agora::rtc::VIDEO_SOURCE_TYPE</a>&#160;</td>
          <td class="paramname"><em>sourceType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classagora_1_1media_1_1_i_video_frame_observer.html#ae60399181e83d7e93ad759b2ab549b97">VideoFrame</a> &amp;&#160;</td>
          <td class="paramname"><em>videoFrame</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Occurs each time the SDK receives a video frame captured by the local camera.</p>
<p>After you successfully register the video frame observer, the SDK triggers this callback each time a video frame is received. In this callback, you can get the video data captured by the local camera. You can then pre-process the data according to your scenarios.</p>
<p>After pre-processing, you can send the processed video data back to the SDK by setting the <code>videoFrame</code> parameter in this callback.</p>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>If you get the video data in RGBA color encoding format, Agora does not support using this callback to send the processed data in RGBA color encoding format back to the SDK.</li>
<li>The video data that this callback gets has not been pre-processed, such as watermarking, cropping content, rotating, or image enhancement.</li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">videoFrame</td><td>A pointer to the video frame: VideoFrame </td></tr>
    <tr><td class="paramname">sourceType</td><td>source type of video frame. See #VIDEO_SOURCE_TYPE. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Determines whether to ignore the current video frame if the pre-processing fails:<ul>
<li>true: Do not ignore.</li>
<li>false: Ignore, in which case this method does not sent the current video frame to the SDK. </li>
</ul>
</dd></dl>

<p>Implemented in <a class="el" href="classagora_1_1media_1_1_i_video_frame_observer_ex.html#a72c5b2bf106471d6bbbba8e752869fd3">agora::media::IVideoFrameObserverEx</a>.</p>

</div>
</div>
<a id="aabbf70d93e52f748b9c03d90a73fe65e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabbf70d93e52f748b9c03d90a73fe65e">&#9670;&nbsp;</a></span>onPreEncodeVideoFrame()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool agora::media::IVideoFrameObserver::onPreEncodeVideoFrame </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceagora_1_1rtc.html#ac6699b3c40e047af097d877115dde751">agora::rtc::VIDEO_SOURCE_TYPE</a>&#160;</td>
          <td class="paramname"><em>sourceType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classagora_1_1media_1_1_i_video_frame_observer.html#ae60399181e83d7e93ad759b2ab549b97">VideoFrame</a> &amp;&#160;</td>
          <td class="paramname"><em>videoFrame</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Occurs each time the SDK receives a video frame before encoding.</p>
<p>After you successfully register the video frame observer, the SDK triggers this callback each time when it receives a video frame. In this callback, you can get the video data before encoding. You can then process the data according to your particular scenarios.</p>
<p>After processing, you can send the processed video data back to the SDK by setting the <code>videoFrame</code> parameter in this callback.</p>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>To get the video data captured from the second screen before encoding, you need to set (1 &lt;&lt; 2) as a frame position through <code>getObservedFramePosition</code>.</li>
<li>The video data that this callback gets has been pre-processed, such as watermarking, cropping content, rotating, or image enhancement.</li>
<li>This callback does not support sending processed RGBA video data back to the SDK.</li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">videoFrame</td><td>A pointer to the video frame: VideoFrame </td></tr>
    <tr><td class="paramname">sourceType</td><td>source type of video frame. See #VIDEO_SOURCE_TYPE. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Determines whether to ignore the current video frame if the pre-processing fails:<ul>
<li>true: Do not ignore.</li>
<li>false: Ignore, in which case this method does not sent the current video frame to the SDK. </li>
</ul>
</dd></dl>

<p>Implemented in <a class="el" href="classagora_1_1media_1_1_i_video_frame_observer_ex.html#a7eba4f2f84c0f718502568148a8cf119">agora::media::IVideoFrameObserverEx</a>.</p>

</div>
</div>
<a id="a0b207e2905a273073f5b4592fa579136"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b207e2905a273073f5b4592fa579136">&#9670;&nbsp;</a></span>onMediaPlayerVideoFrame()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool agora::media::IVideoFrameObserver::onMediaPlayerVideoFrame </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classagora_1_1media_1_1_i_video_frame_observer.html#ae60399181e83d7e93ad759b2ab549b97">VideoFrame</a> &amp;&#160;</td>
          <td class="paramname"><em>videoFrame</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mediaPlayerId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Occurs each time the SDK receives a video frame decoded by the MediaPlayer.</p>
<p>After you successfully register the video frame observer, the SDK triggers this callback each time a video frame is decoded. In this callback, you can get the video data decoded by the MediaPlayer. You can then pre-process the data according to your scenarios.</p>
<p>After pre-processing, you can send the processed video data back to the SDK by setting the <code>videoFrame</code> parameter in this callback.</p>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>This callback will not be affected by the return values of <a class="el" href="classagora_1_1media_1_1_i_video_frame_observer.html#af147400f7477416724546852894bb7da">getVideoFrameProcessMode</a>, <a class="el" href="classagora_1_1media_1_1_i_video_frame_observer.html#afd5bb439a9951a83f08d8c0a81468dcb">getRotationApplied</a>, <a class="el" href="classagora_1_1media_1_1_i_video_frame_observer.html#afc5cce81bf1c008e9335a0423ca45991">getMirrorApplied</a>, <a class="el" href="classagora_1_1media_1_1_i_video_frame_observer.html#ad4c174389264630ffb1b2d24c6030013">getObservedFramePosition</a>.</li>
<li>On Android, this callback is not affected by the return value of <a class="el" href="classagora_1_1media_1_1_i_video_frame_observer.html#abce7f145af45f90bfd8c9b0211c875db">getVideoFormatPreference</a></li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">videoFrame</td><td>A pointer to the video frame: VideoFrame </td></tr>
    <tr><td class="paramname">mediaPlayerId</td><td>ID of the mediaPlayer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Determines whether to ignore the current video frame if the pre-processing fails:<ul>
<li>true: Do not ignore.</li>
<li>false: Ignore, in which case this method does not sent the current video frame to the SDK. </li>
</ul>
</dd></dl>

<p>Implemented in <a class="el" href="classagora_1_1media_1_1_i_video_frame_observer_ex.html#a347c91037dafe744d582635ca57b769f">agora::media::IVideoFrameObserverEx</a>.</p>

</div>
</div>
<a id="a55a50434efe819a3dcb74ffd0799b847"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55a50434efe819a3dcb74ffd0799b847">&#9670;&nbsp;</a></span>onRenderVideoFrame()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool agora::media::IVideoFrameObserver::onRenderVideoFrame </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>channelId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceagora_1_1rtc.html#ab650539cb2bdcf8382d0aa32c6d70aa7">rtc::uid_t</a>&#160;</td>
          <td class="paramname"><em>remoteUid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classagora_1_1media_1_1_i_video_frame_observer.html#ae60399181e83d7e93ad759b2ab549b97">VideoFrame</a> &amp;&#160;</td>
          <td class="paramname"><em>videoFrame</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Occurs each time the SDK receives a video frame sent by the remote user.</p>
<p>After you successfully register the video frame observer, the SDK triggers this callback each time a video frame is received. In this callback, you can get the video data sent by the remote user. You can then post-process the data according to your scenarios.</p>
<p>After post-processing, you can send the processed data back to the SDK by setting the <code>videoFrame</code> parameter in this callback.</p>
<dl class="section note"><dt>Note</dt><dd>This callback does not support sending processed RGBA video data back to the SDK.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channelId</td><td>The channel name </td></tr>
    <tr><td class="paramname">remoteUid</td><td>ID of the remote user who sends the current video frame. </td></tr>
    <tr><td class="paramname">videoFrame</td><td>A pointer to the video frame: VideoFrame </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Determines whether to ignore the current video frame if the post-processing fails:<ul>
<li>true: Do not ignore.</li>
<li>false: Ignore, in which case this method does not sent the current video frame to the SDK. </li>
</ul>
</dd></dl>

<p>Implemented in <a class="el" href="classagora_1_1media_1_1_i_video_frame_observer_ex.html#ad1d6d31684383416a6e63aff550d7c33">agora::media::IVideoFrameObserverEx</a>.</p>

</div>
</div>
<a id="ad4c50b6e2052a1b656fdca43439c55cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4c50b6e2052a1b656fdca43439c55cd">&#9670;&nbsp;</a></span>onTranscodedVideoFrame()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool agora::media::IVideoFrameObserver::onTranscodedVideoFrame </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classagora_1_1media_1_1_i_video_frame_observer.html#ae60399181e83d7e93ad759b2ab549b97">VideoFrame</a> &amp;&#160;</td>
          <td class="paramname"><em>videoFrame</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implemented in <a class="el" href="classagora_1_1media_1_1_i_video_frame_observer_ex.html#a623cb897da31a3d5222cd987d0390f99">agora::media::IVideoFrameObserverEx</a>.</p>

</div>
</div>
<a id="af147400f7477416724546852894bb7da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af147400f7477416724546852894bb7da">&#9670;&nbsp;</a></span>getVideoFrameProcessMode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classagora_1_1media_1_1_i_video_frame_observer.html#aa0a690ef35d3813937a396d39ef74e65">VIDEO_FRAME_PROCESS_MODE</a> agora::media::IVideoFrameObserver::getVideoFrameProcessMode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Occurs each time the SDK receives a video frame and prompts you to set the process mode of the video frame.</p>
<p>After you successfully register the video frame observer, the SDK triggers this callback each time it receives a video frame. You need to set your preferred process mode in the return value of this callback. </p><dl class="section return"><dt>Returns</dt><dd>VIDEO_FRAME_PROCESS_MODE. </dd></dl>

</div>
</div>
<a id="abce7f145af45f90bfd8c9b0211c875db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abce7f145af45f90bfd8c9b0211c875db">&#9670;&nbsp;</a></span>getVideoFormatPreference()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespaceagora_1_1media_1_1base.html#ab530007c5b083146b9cebefb46f931e2">base::VIDEO_PIXEL_FORMAT</a> agora::media::IVideoFrameObserver::getVideoFormatPreference </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets the format of the raw video data output by the SDK.</p>
<p>If you want to get raw video data in a color encoding format other than YUV 420, register this callback when calling <code>registerVideoFrameObserver</code>. After you successfully register the video frame observer, the SDK triggers this callback each time it receives a video frame. You need to set your preferred video data in the return value of this callback.</p>
<dl class="section note"><dt>Note</dt><dd>If you want the video captured by the sender to be the original format, set the original video data format to VIDEO_PIXEL_DEFAULT in the return value. On different platforms, the original video pixel format is also different, for the actual video pixel format, see <code>VideoFrame</code>.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Sets the video format. See VIDEO_PIXEL_FORMAT. </dd></dl>

</div>
</div>
<a id="afd5bb439a9951a83f08d8c0a81468dcb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd5bb439a9951a83f08d8c0a81468dcb">&#9670;&nbsp;</a></span>getRotationApplied()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool agora::media::IVideoFrameObserver::getRotationApplied </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Occurs each time the SDK receives a video frame, and prompts you whether to rotate the captured video.</p>
<p>If you want to rotate the captured video according to the rotation member in the <code>VideoFrame</code> class, register this callback by calling <code>registerVideoFrameObserver</code>. After you successfully register the video frame observer, the SDK triggers this callback each time it receives a video frame. You need to set whether to rotate the video frame in the return value of this callback.</p>
<dl class="section note"><dt>Note</dt><dd>This function only supports video data in RGBA or YUV420.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Determines whether to rotate.<ul>
<li><code>true</code>: Rotate the captured video.</li>
<li><code>false</code>: (Default) Do not rotate the captured video. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="afc5cce81bf1c008e9335a0423ca45991"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc5cce81bf1c008e9335a0423ca45991">&#9670;&nbsp;</a></span>getMirrorApplied()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool agora::media::IVideoFrameObserver::getMirrorApplied </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Occurs each time the SDK receives a video frame and prompts you whether or not to mirror the captured video.</p>
<p>If the video data you want to obtain is a mirror image of the original video, you need to register this callback when calling <code>registerVideoFrameObserver</code>. After you successfully register the video frame observer, the SDK triggers this callback each time it receives a video frame. You need to set whether or not to mirror the video frame in the return value of this callback.</p>
<dl class="section note"><dt>Note</dt><dd>This function only supports video data in RGBA and YUV420 formats.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Determines whether to mirror.<ul>
<li><code>true</code>: Mirror the captured video.</li>
<li><code>false</code>: (Default) Do not mirror the captured video. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ad4c174389264630ffb1b2d24c6030013"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4c174389264630ffb1b2d24c6030013">&#9670;&nbsp;</a></span>getObservedFramePosition()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual uint32_t agora::media::IVideoFrameObserver::getObservedFramePosition </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets the frame position for the video observer.</p>
<p>After you successfully register the video observer, the SDK triggers this callback each time it receives a video frame. You can determine which position to observe by setting the return value. The SDK provides 3 positions for observer. Each position corresponds to a callback function:</p>
<p>POSITION_POST_CAPTURER(1 &lt;&lt; 0): The position after capturing the video data, which corresponds to the onCaptureVideoFrame callback. POSITION_PRE_RENDERER(1 &lt;&lt; 1): The position before receiving the remote video data, which corresponds to the onRenderVideoFrame callback. POSITION_PRE_ENCODER(1 &lt;&lt; 2): The position before encoding the video data, which corresponds to the onPreEncodeVideoFrame callback.</p>
<p>To observe multiple frame positions, use '|' (the OR operator). This callback observes POSITION_POST_CAPTURER(1 &lt;&lt; 0) and POSITION_PRE_RENDERER(1 &lt;&lt; 1) by default. To conserve the system consumption, you can reduce the number of frame positions that you want to observe.</p>
<dl class="section return"><dt>Returns</dt><dd>A bit mask that controls the frame position of the video observer: VIDEO_OBSERVER_POSITION. </dd></dl>

</div>
</div>
<a id="a2d6db5dbead74855002812bac087c9e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d6db5dbead74855002812bac087c9e2">&#9670;&nbsp;</a></span>isExternal()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool agora::media::IVideoFrameObserver::isExternal </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Indicate if the observer is for internal use. Note: Never override this function </p><dl class="section return"><dt>Returns</dt><dd><ul>
<li>true: the observer is for external use</li>
<li>false: the observer is for internal use </li>
</ul>
</dd></dl>

<p>Reimplemented in <a class="el" href="classagora_1_1media_1_1_i_video_frame_observer_ex.html#a06c8304fa68d347163837583b911de8a">agora::media::IVideoFrameObserverEx</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.18
</small></address>
</body>
</html>
